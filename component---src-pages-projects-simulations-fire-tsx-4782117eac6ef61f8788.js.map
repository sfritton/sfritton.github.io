{"version":3,"sources":["webpack:///./src/simulations/util/PhysicsSimulation.ts","webpack:///./node_modules/@babel/runtime/helpers/esm/createClass.js","webpack:///./src/simulations/fire-new/constants.ts","webpack:///./src/simulations/fire-new/Particle.ts","webpack:///./src/simulations/fire-new/Fire.ts","webpack:///./src/simulations/fire-new/index.ts","webpack:///./src/pages/projects/simulations/fire.tsx","webpack:///./src/simulations/util/helpers.ts"],"names":["PhysicsSimulation","p5","verbose","startMS","currMS","prevMS","frames","setup","this","millis","calculateTime","fps","Math","floor","console","log","Simulation","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","EMIT_CENTER","Particle","center","color","r","g","b","position","randomPosition","velocity","randomVelocity","life","randomFromTo","remainingLife","Constructor","protoProps","staticProps","render","strokeWeight","size","stroke","point","x","y","randomAngle","random","PI","randomRadius","sqrt","cos","sin","randomX","randomY","magnitude","unitVector","randomSpeed","update","deltaT","updatePosition","updateColor","updateLife","percent","prototype","Fire","particles","particleFraction","width","height","emitParticles","simulate","updateParticles","killParticles","background","numNewParticles","numWholeParticles","push","filter","particle","isDead","fireNew","fire","draw","FirePage","Layout","title","sketch","min","max"],"mappings":"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","file":"component---src-pages-projects-simulations-fire-tsx-4782117eac6ef61f8788.js","sourcesContent":["import P5 from 'p5';\nimport { Simulation } from './Simulation';\n\nexport class PhysicsSimulation extends Simulation {\n  /** Enable additional console logging. Just average FPS for now. */\n  verbose = false;\n  /** A timestamp of the simulation start time. */\n  startMS = 0;\n  /** A timestamp of the beginning of the current frame. */\n  currMS = 0;\n  /** A timestamp of the beginning of the previous frame. */\n  prevMS = 0;\n  /** The total number of frames that have been rendered. */\n  frames = 0;\n\n  /** Pass the verbose flag to show the average FPS */\n  constructor(p5: P5, verbose?: boolean) {\n    super(p5);\n    this.verbose = verbose ?? false;\n  }\n\n  /** Call during p5.setup to create the canvas and initialize the timing. */\n  setup() {\n    // create the canvas\n    super.setup();\n\n    // Initialize the timing\n    this.currMS = this.p5.millis();\n    this.startMS = this.currMS;\n    this.prevMS = this.currMS;\n  }\n\n  /** Determine how many seconds have passed since the previous frame. */\n  calculateTime() {\n    this.frames++;\n    this.prevMS = this.currMS;\n    this.currMS = this.p5.millis();\n\n    if (this.verbose) {\n      const fps = Math.floor((this.frames / (this.currMS - this.startMS)) * 1000);\n      console.log(`Running at ${fps} FPS`);\n    }\n\n    return (this.currMS - this.prevMS) / 1000;\n  }\n}\n","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}","// emitter\nexport const EMIT_RADIUS = 50;\nexport const EMIT_CENTER = { x: 1 / 2, y: 3 / 4 };\n\n/** Rate at which particle color changes */\nexport const COLOR_SPEED = 10;\n\n// forces\nexport const GRAVITY = -20;\n\n// particles\nexport const PARTICLES_PER_SECOND = 40;\nexport const PARTICLE_SPEED = 10;\nexport const PARTICLE_DIAMETER = 50;\nexport const PARTICLE_MIN_LIFE = 2;\nexport const PARTICLE_MAX_LIFE = 4;\n","import P5 from 'p5';\nimport { randomFromTo } from '../util/helpers';\nimport { Coordinates } from '../util/types';\nimport {\n  PARTICLE_MIN_LIFE,\n  PARTICLE_MAX_LIFE,\n  PARTICLE_DIAMETER,\n  EMIT_RADIUS,\n  PARTICLE_SPEED,\n  COLOR_SPEED,\n  GRAVITY,\n} from './constants';\n\ninterface Color {\n  r: number;\n  g: number;\n  b: number;\n}\n\nexport class Particle {\n  p5: P5;\n  center: Coordinates;\n  position: Coordinates;\n  velocity: Coordinates;\n  life: number;\n  remainingLife: number;\n  color: Color = {\n    r: 255,\n    g: 255,\n    b: 255,\n  };\n\n  constructor(p5: P5, center: Coordinates) {\n    this.p5 = p5;\n    this.center = center;\n    this.position = this.randomPosition();\n    this.velocity = this.randomVelocity();\n    this.life = randomFromTo(PARTICLE_MIN_LIFE, PARTICLE_MAX_LIFE);\n    this.remainingLife = this.life;\n  }\n\n  render() {\n    this.p5.strokeWeight(this.size);\n    this.p5.stroke(this.color.r, this.color.g, this.color.b);\n    this.p5.point(this.position.x, this.position.y);\n  }\n\n  /** Choose a random position inside a circle */\n  randomPosition(): Coordinates {\n    const randomAngle = Math.random() * 2 * this.p5.PI;\n    const randomRadius = EMIT_RADIUS * Math.sqrt(Math.random());\n\n    return {\n      x: this.center.x + randomRadius * this.p5.cos(randomAngle),\n      y: this.center.y + randomRadius * this.p5.sin(randomAngle),\n    };\n  }\n\n  randomVelocity(): Coordinates {\n    const randomX = randomFromTo(-1, 1);\n    const randomY = Math.random();\n\n    const magnitude = Math.sqrt(randomX * randomX + randomY * randomY);\n\n    const unitVector = {\n      x: randomX / magnitude,\n      y: randomY / magnitude,\n    };\n\n    const randomSpeed = Math.random();\n\n    return {\n      x: unitVector.x * randomSpeed * PARTICLE_SPEED,\n      y: (unitVector.y * randomSpeed * PARTICLE_SPEED) / 4,\n    };\n  }\n\n  update(deltaT: number) {\n    this.updatePosition(deltaT);\n    this.updateColor(deltaT);\n    this.updateLife(deltaT);\n  }\n\n  get isDead() {\n    return this.remainingLife <= 0;\n  }\n\n  get size() {\n    const percent = this.remainingLife / this.life;\n    return this.p5.sin(this.p5.PI * percent) * PARTICLE_DIAMETER;\n  }\n\n  updateLife(deltaT: number) {\n    this.remainingLife -= deltaT;\n  }\n\n  updatePosition(deltaT: number) {\n    // update velocity\n    this.velocity.y += GRAVITY * deltaT;\n\n    // update position\n    this.position.x += this.velocity.x * deltaT;\n    this.position.y += this.velocity.y * deltaT;\n  }\n\n  updateColor(deltaT: number) {\n    const percent = this.remainingLife / this.life;\n\n    if (percent >= 0.95) return;\n\n    this.color.g = Math.floor(this.color.g - COLOR_SPEED * deltaT);\n    this.color.b = Math.floor(this.color.b - 10 * COLOR_SPEED * deltaT);\n  }\n}\n","import { PhysicsSimulation } from '../util/PhysicsSimulation';\nimport { Particle } from './Particle';\nimport { EMIT_CENTER, PARTICLES_PER_SECOND } from './constants';\nimport { Coordinates } from '../util/types';\n\nexport class Fire extends PhysicsSimulation {\n  particles: Particle[] = [];\n\n  /**\n   * A place to store partial particles between frames.\n   * After this reaches a value of 1,\n   * an extra particle will be added, and this counter will be reset.\n   */\n  particleFraction = 0;\n  center: Coordinates = { x: 0, y: 0 };\n\n  setup() {\n    super.setup();\n    this.center = {\n      x: this.p5.width * EMIT_CENTER.x,\n      y: this.p5.height * EMIT_CENTER.y,\n    };\n\n    // start out with a few particles\n    this.emitParticles(1);\n  }\n\n  simulate() {\n    const deltaT = this.calculateTime();\n    if (this.verbose) {\n      console.log(`${this.particles.length} particles`);\n    }\n\n    // emit new particles\n    this.emitParticles(deltaT);\n\n    // update existing particles\n    this.updateParticles(deltaT);\n\n    // remove dead particles\n    this.killParticles();\n  }\n\n  render() {\n    this.p5.background(0);\n\n    for (let i = 0; i < this.particles.length; i++) {\n      this.particles[i].render();\n    }\n  }\n\n  emitParticles(deltaT: number) {\n    const numNewParticles = PARTICLES_PER_SECOND * deltaT;\n    let numWholeParticles = Math.floor(numNewParticles);\n    this.particleFraction += numNewParticles - numWholeParticles;\n\n    if (this.particleFraction >= 1) {\n      this.particleFraction--;\n      numWholeParticles++;\n    }\n\n    for (let i = 0; i < numWholeParticles; i++) {\n      this.particles.push(new Particle(this.p5, this.center));\n    }\n  }\n\n  updateParticles(deltaT: number) {\n    for (let i = 0; i < this.particles.length; i++) {\n      this.particles[i].update(deltaT);\n    }\n  }\n\n  killParticles() {\n    this.particles = this.particles.filter((particle) => !particle.isDead);\n  }\n}\n","import P5 from 'p5';\nimport { Fire } from './Fire';\n\nexport const fireNew = (p5: P5) => {\n  const fire = new Fire(p5, true);\n\n  p5.setup = function () {\n    fire.setup();\n  };\n\n  p5.draw = function () {\n    fire.simulate();\n    fire.render();\n  };\n};\n","import React from 'react';\nimport { PageProps } from 'gatsby';\nimport Layout from '../../../components/Layout';\nimport { Simulation } from '../../../components/Simulation';\nimport { fireNew } from '../../../simulations/fire-new';\n\nconst FirePage: React.FC<PageProps> = () => {\n  return (\n    <Layout title=\"Fire Particle System\">\n      <h1>Fire Particle System</h1>\n      <Simulation sketch={fireNew} />\n      <div>\n        Particle systems are always a fun project. A few simple rules, plus some randomness, and\n        some really cool behaviors emerge. Each particle in this system starts out small and white,\n        then grows and fades to red before shrinking again. Multiply that by 100 particles with\n        random variations, and you have a nice little flame. It was an interesting challenge to get\n        a decent-looking fire with so few particles. The original version of this system ran in Java\n        and had nearly 10,000 particles. Unfortunately, JavaScript just isn't fast enough to run a\n        massive system.\n      </div>\n    </Layout>\n  );\n};\n\nexport default FirePage;\n","export const randomFromTo = (min: number, max: number) => (max - min) * Math.random() + min;\n"],"sourceRoot":""}